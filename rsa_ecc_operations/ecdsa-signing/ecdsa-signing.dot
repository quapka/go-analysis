digraph graphviz {
  "crypto/elliptic.p256GetScalar" -> "(*math/big.Int).SetBytes"
  "crypto/elliptic.p256GetScalar" -> "(*math/big.Int).Cmp"
  "crypto/elliptic.p256GetScalar" -> "(*math/big.Int).Mod"
  "crypto/elliptic.fromBig" -> "(*math/big.Int).Bits"
  "crypto/elliptic.p256GetScalar" -> "crypto/elliptic.fromBig"
  "(crypto/elliptic.p256Curve).ScalarBaseMult" -> "crypto/elliptic.p256GetScalar"
  "runtime.clearpools" -> "crypto/elliptic.initAll"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Sqr"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Mul"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Sqr"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Mul"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Sqr"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Mul"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Sqr"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Mul"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Sqr"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Mul"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Sqr"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Mul"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Sqr"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Mul"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Sqr"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Mul"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Sqr"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Mul"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Sqr"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Mul"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Sqr"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Mul"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Sqr"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Mul"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Sqr"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Mul"
  "crypto/elliptic.initTable" -> "crypto/elliptic.p256Inverse"
  "crypto/elliptic.initTable" -> "crypto/elliptic.p256Sqr"
  "crypto/elliptic.initTable" -> "crypto/elliptic.p256Mul"
  "crypto/elliptic.initTable" -> "crypto/elliptic.p256Mul"
  "crypto/elliptic.initTable" -> "crypto/elliptic.p256Mul"
  "crypto/elliptic.initTable" -> "crypto/elliptic.p256PointDoubleAsm"
  "crypto/elliptic.initTable" -> "crypto/elliptic.p256PointDoubleAsm"
  "crypto/elliptic.initTable" -> "crypto/elliptic.p256PointAddAsm"
  "runtime.clearpools" -> "crypto/elliptic.initTable"
  "runtime.mstart1" -> "crypto/elliptic.initTable"
  "runtime.mstart1" -> "crypto/elliptic.initAll"
  "io.ReadAtLeast" -> "(*crypto/ecdsa.zr).Read"
  "(*bufio.Reader).Read" -> "(*crypto/ecdsa.zr).Read"
  "(*bufio.Reader).Read" -> "(*crypto/ecdsa.zr).Read"
  "(crypto/cipher.StreamReader).Read" -> "(*crypto/ecdsa.zr).Read"
  "(crypto/rand.hideAgainReader).Read" -> "(*crypto/ecdsa.zr).Read"
  "(*crypto/rand.devReader).Read" -> "(*crypto/ecdsa.zr).Read"
  "(*bufio.Reader).fill" -> "(*crypto/ecdsa.zr).Read"
  "crypto/elliptic.initP224" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initP224" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initP224" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initP224" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initP224" -> "(*math/big.Int).SetString"
  "crypto/elliptic.p224FromBig" -> "(*math/big.Int).Bytes"
  "crypto/elliptic.p224FromBig" -> "crypto/elliptic.get28BitsFromEnd"
  "crypto/elliptic.p224FromBig" -> "crypto/elliptic.get28BitsFromEnd"
  "crypto/elliptic.p224FromBig" -> "crypto/elliptic.get28BitsFromEnd"
  "crypto/elliptic.p224FromBig" -> "crypto/elliptic.get28BitsFromEnd"
  "crypto/elliptic.p224FromBig" -> "crypto/elliptic.get28BitsFromEnd"
  "crypto/elliptic.p224FromBig" -> "crypto/elliptic.get28BitsFromEnd"
  "crypto/elliptic.p224FromBig" -> "crypto/elliptic.get28BitsFromEnd"
  "crypto/elliptic.p224FromBig" -> "crypto/elliptic.get28BitsFromEnd"
  "crypto/elliptic.initP224" -> "crypto/elliptic.p224FromBig"
  "crypto/elliptic.initP224" -> "crypto/elliptic.p224FromBig"
  "crypto/elliptic.initP224" -> "crypto/elliptic.p224FromBig"
  "crypto/elliptic.initAll" -> "crypto/elliptic.initP224"
  "crypto/elliptic.initP256" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initP256" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initP256" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initP256" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initP256" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initAll" -> "crypto/elliptic.initP256"
  "crypto/elliptic.initP384" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initP384" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initP384" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initP384" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initP384" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initAll" -> "crypto/elliptic.initP384"
  "crypto/elliptic.initP521" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initP521" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initP521" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initP521" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initP521" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initAll" -> "crypto/elliptic.initP521"
  "(*sync.Once).Do" -> "crypto/elliptic.initAll"
  "(*sync.Once).Do" -> "crypto/elliptic.initTable"
  "(*crypto/elliptic.p256Point).p256BaseMult" -> "(*sync.Once).Do"
  "(*crypto/elliptic.p256Point).p256BaseMult" -> "crypto/elliptic.boothW6"
  "(*crypto/elliptic.p256Point).p256BaseMult" -> "crypto/elliptic.p256SelectBase"
  "(*crypto/elliptic.p256Point).p256BaseMult" -> "crypto/elliptic.p256NegCond"
  "(*crypto/elliptic.p256Point).p256BaseMult" -> "crypto/elliptic.boothW6"
  "(*crypto/elliptic.p256Point).p256BaseMult" -> "crypto/elliptic.p256SelectBase"
  "(*crypto/elliptic.p256Point).p256BaseMult" -> "crypto/elliptic.p256PointAddAffineAsm"
  "(crypto/elliptic.p256Curve).ScalarBaseMult" -> "(*crypto/elliptic.p256Point).p256BaseMult"
  "(*crypto/elliptic.p256Point).p256PointToAffine" -> "crypto/elliptic.p256Inverse"
  "(*crypto/elliptic.p256Point).p256PointToAffine" -> "crypto/elliptic.p256Sqr"
  "(*crypto/elliptic.p256Point).p256PointToAffine" -> "crypto/elliptic.p256Mul"
  "(*crypto/elliptic.p256Point).p256PointToAffine" -> "crypto/elliptic.p256Mul"
  "(*crypto/elliptic.p256Point).p256PointToAffine" -> "crypto/elliptic.p256Mul"
  "(*crypto/elliptic.p256Point).p256PointToAffine" -> "crypto/elliptic.p256FromMont"
  "(*crypto/elliptic.p256Point).p256PointToAffine" -> "crypto/elliptic.p256FromMont"
  "(*crypto/elliptic.p256Point).p256PointToAffine" -> "crypto/elliptic.p256LittleToBig"
  "(*crypto/elliptic.p256Point).p256PointToAffine" -> "crypto/elliptic.p256LittleToBig"
  "(*crypto/elliptic.p256Point).p256PointToAffine" -> "(*math/big.Int).SetBytes"
  "(*crypto/elliptic.p256Point).p256PointToAffine" -> "(*math/big.Int).SetBytes"
  "(crypto/elliptic.p256Curve).ScalarBaseMult" -> "(*crypto/elliptic.p256Point).p256PointToAffine"
  "crypto/ecdsa.randFieldElement" -> "(*crypto/elliptic.CurveParams).Params"
  "crypto/ecdsa.randFieldElement" -> "(*math/big.Int).Mod"
  "crypto/ecdsa.randFieldElement" -> "(crypto/elliptic.p256Curve).Params"
  "crypto/ecdsa.randFieldElement" -> "(*math/big.Int).Add"
  "crypto/ecdsa.randFieldElement" -> "io.ReadFull"
  "crypto/ecdsa.randFieldElement" -> "(*math/big.Int).SetBytes"
  "crypto/ecdsa.randFieldElement" -> "(*math/big.Int).Sub"
  "crypto/ecdsa.GenerateKey" -> "crypto/ecdsa.randFieldElement"
  "crypto/ecdsa.GenerateKey" -> "(*math/big.Int).Bytes"
  "(*crypto/elliptic.CurveParams).ScalarMult" -> "(*math/big.Int).SetInt64"
  "(*crypto/elliptic.CurveParams).affineFromJacobian" -> "(*math/big.Int).Sign"
  "(*crypto/elliptic.CurveParams).affineFromJacobian" -> "(*math/big.Int).ModInverse"
  "(*crypto/elliptic.CurveParams).affineFromJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).affineFromJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).affineFromJacobian" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).affineFromJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).affineFromJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).affineFromJacobian" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).ScalarMult" -> "(*crypto/elliptic.CurveParams).affineFromJacobian"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Sub"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Sign"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Add"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Add"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Set"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Lsh"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Add"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Lsh"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Sub"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Sign"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Add"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Add"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Sub"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Sign"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Add"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Sub"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Sign"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Add"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Lsh"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Sub"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Sign"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Add"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Lsh"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Sub"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Sign"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Add"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).ScalarMult" -> "(*crypto/elliptic.CurveParams).doubleJacobian"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Sign"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Set"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Set"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Set"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Sign"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Set"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Set"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Set"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Sub"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Sign"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Sign"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Add"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Lsh"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Sub"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Sign"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Add"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Sign"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*crypto/elliptic.CurveParams).doubleJacobian"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Lsh"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Set"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Sub"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Sub"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Sub"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Set"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Sub"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Lsh"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Sub"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Add"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Sub"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Sub"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).ScalarMult" -> "(*crypto/elliptic.CurveParams).addJacobian"
  "(*crypto/elliptic.CurveParams).ScalarBaseMult" -> "(*crypto/elliptic.CurveParams).ScalarMult"
  "crypto/ecdsa.GenerateKey" -> "(*crypto/elliptic.CurveParams).ScalarBaseMult"
  "crypto/ecdsa.GenerateKey" -> "(crypto/elliptic.p256Curve).ScalarBaseMult"
  "crypto/internal/randutil.MaybeReadByte" -> "(*crypto/ecdsa.zr).Read"
  "crypto/ecdsa.Sign" -> "crypto/internal/randutil.MaybeReadByte"
  "crypto/ecdsa.Sign" -> "(*crypto/elliptic.CurveParams).Params"
  "crypto/ecdsa.Sign" -> "(*crypto/sha512.digest).Write"
  "crypto/ecdsa.Sign" -> "(crypto/elliptic.p256Curve).Params"
  "crypto/ecdsa.Sign" -> "(*crypto/sha512.digest).Sum"
  "crypto/ecdsa.Sign" -> "io.ReadFull"
  "crypto/ecdsa.Sign" -> "crypto/sha512.New"
  "crypto/ecdsa.Sign" -> "(*math/big.Int).Bytes"
  "crypto/ecdsa.Sign" -> "crypto/aes.NewCipher"
  "crypto/ecdsa.Sign" -> "crypto/cipher.NewCTR"
  "crypto/ecdsa.Sign" -> "(*crypto/elliptic.CurveParams).Params"
  "crypto/ecdsa.Sign" -> "(*crypto/sha512.digest).Write"
  "crypto/ecdsa.Sign" -> "(crypto/elliptic.p256Curve).Params"
  "crypto/ecdsa.Sign" -> "(*crypto/sha512.digest).Write"
  "crypto/ecdsa.Sign" -> "(*math/big.Int).Sign"
  "crypto/ecdsa.Sign" -> "crypto/ecdsa.randFieldElement"
  "(crypto/elliptic.p256Curve).Inverse" -> "(*math/big.Int).Sign"
  "(crypto/elliptic.p256Curve).Inverse" -> "(*math/big.Int).Neg"
  "(crypto/elliptic.p256Curve).Inverse" -> "(*math/big.Int).Cmp"
  "(crypto/elliptic.p256Curve).Inverse" -> "(*math/big.Int).Mod"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.fromBig"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdMul"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdSqr"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdMul"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdMul"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdMul"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdSqr"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdMul"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdSqr"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdMul"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdSqr"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdMul"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdMul"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdSqr"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdMul"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdSqr"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdMul"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdSqr"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdMul"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdSqr"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdMul"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdSqr"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdMul"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdSqr"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdMul"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdMul"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256LittleToBig"
  "(crypto/elliptic.p256Curve).Inverse" -> "(*math/big.Int).SetBytes"
  "crypto/ecdsa.Sign" -> "(crypto/elliptic.p256Curve).Inverse"
  "crypto/ecdsa.Sign" -> "(*math/big.Int).Mul"
  "crypto/ecdsa.Sign" -> "(*math/big.Int).Bytes"
  "crypto/ecdsa.Sign" -> "(*crypto/elliptic.CurveParams).ScalarBaseMult"
  "crypto/ecdsa.Sign" -> "(*math/big.Int).Sign"
  "crypto/ecdsa.Sign" -> "(crypto/elliptic.p256Curve).ScalarBaseMult"
  "crypto/ecdsa.Sign" -> "(*math/big.Int).Mod"
  "crypto/ecdsa.Sign" -> "(*math/big.Int).Mod"
  "crypto/ecdsa.Sign" -> "(*math/big.Int).Sign"
  "crypto/ecdsa.fermatInverse" -> "math/big.NewInt"
  "crypto/ecdsa.fermatInverse" -> "(*math/big.Int).Sub"
  "crypto/ecdsa.fermatInverse" -> "(*math/big.Int).Exp"
  "crypto/ecdsa.Sign" -> "crypto/ecdsa.fermatInverse"
  "crypto/ecdsa.hashToInt" -> "(*crypto/elliptic.CurveParams).Params"
  "crypto/ecdsa.hashToInt" -> "(*math/big.Int).SetBytes"
  "crypto/ecdsa.hashToInt" -> "(crypto/elliptic.p256Curve).Params"
  "crypto/ecdsa.hashToInt" -> "(*math/big.Int).Rsh"
  "crypto/ecdsa.hashToInt" -> "(*math/big.Int).BitLen"
  "crypto/ecdsa.Sign" -> "crypto/ecdsa.hashToInt"
  "crypto/ecdsa.Sign" -> "(*math/big.Int).Mul"
  "crypto/ecdsa.Sign" -> "(*math/big.Int).Add"
  "crypto/elliptic.P256" -> "(*sync.Once).Do"
  "github.com/quapka/go-analysis/rsa_ecc_operations/ecdsa-signing.main" -> "crypto/elliptic.P256"
  "github.com/quapka/go-analysis/rsa_ecc_operations/ecdsa-signing.main" -> "crypto/ecdsa.GenerateKey"
  "github.com/quapka/go-analysis/rsa_ecc_operations/ecdsa-signing.main" -> "crypto/ecdsa.Sign"
  "(crypto/elliptic.p256Curve).ScalarMult" -> "crypto/elliptic.p256GetScalar"
  "crypto/elliptic.maybeReduceModP" -> "(*math/big.Int).Cmp"
  "crypto/elliptic.maybeReduceModP" -> "(*math/big.Int).Mod"
  "(crypto/elliptic.p256Curve).ScalarMult" -> "crypto/elliptic.maybeReduceModP"
  "(crypto/elliptic.p256Curve).ScalarMult" -> "crypto/elliptic.fromBig"
  "(crypto/elliptic.p256Curve).ScalarMult" -> "crypto/elliptic.maybeReduceModP"
  "(crypto/elliptic.p256Curve).ScalarMult" -> "crypto/elliptic.fromBig"
  "(crypto/elliptic.p256Curve).ScalarMult" -> "crypto/elliptic.p256Mul"
  "(crypto/elliptic.p256Curve).ScalarMult" -> "crypto/elliptic.p256Mul"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "(*crypto/elliptic.p256Point).p256StorePoint"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "(*crypto/elliptic.p256Point).p256StorePoint"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "(*crypto/elliptic.p256Point).p256StorePoint"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "(*crypto/elliptic.p256Point).p256StorePoint"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "(*crypto/elliptic.p256Point).p256StorePoint"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointAddAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointAddAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointAddAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "(*crypto/elliptic.p256Point).p256StorePoint"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "(*crypto/elliptic.p256Point).p256StorePoint"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "(*crypto/elliptic.p256Point).p256StorePoint"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "(*crypto/elliptic.p256Point).p256StorePoint"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "(*crypto/elliptic.p256Point).p256StorePoint"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointAddAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointAddAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "(*crypto/elliptic.p256Point).p256StorePoint"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "(*crypto/elliptic.p256Point).p256StorePoint"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "(*crypto/elliptic.p256Point).p256StorePoint"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "(*crypto/elliptic.p256Point).p256StorePoint"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointAddAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointAddAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "(*crypto/elliptic.p256Point).p256StorePoint"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "(*crypto/elliptic.p256Point).p256StorePoint"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.boothW5"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256Select"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.boothW5"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256Select"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256NegCond"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointAddAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256MovCond"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256MovCond"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.boothW5"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256Select"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256NegCond"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointAddAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256MovCond"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256MovCond"
  "(crypto/elliptic.p256Curve).ScalarMult" -> "(*crypto/elliptic.p256Point).p256ScalarMult"
  "(crypto/elliptic.p256Curve).ScalarMult" -> "(*crypto/elliptic.p256Point).p256PointToAffine"
  "crypto/elliptic.scalarIsZero" -> "crypto/elliptic.uint64IsZero"
  "crypto/elliptic.init" -> "io.init"
  "crypto/elliptic.init" -> "math/big.init"
  "crypto/elliptic.init" -> "sync.init"
  "(crypto/elliptic.p256Curve).CombinedMult" -> "crypto/elliptic.p256GetScalar"
  "(crypto/elliptic.p256Curve).CombinedMult" -> "crypto/elliptic.scalarIsZero"
  "(crypto/elliptic.p256Curve).CombinedMult" -> "(*crypto/elliptic.p256Point).p256BaseMult"
  "(crypto/elliptic.p256Curve).CombinedMult" -> "crypto/elliptic.p256GetScalar"
  "(crypto/elliptic.p256Curve).CombinedMult" -> "crypto/elliptic.scalarIsZero"
  "(crypto/elliptic.p256Curve).CombinedMult" -> "crypto/elliptic.maybeReduceModP"
  "(crypto/elliptic.p256Curve).CombinedMult" -> "crypto/elliptic.fromBig"
  "(crypto/elliptic.p256Curve).CombinedMult" -> "crypto/elliptic.maybeReduceModP"
  "(crypto/elliptic.p256Curve).CombinedMult" -> "crypto/elliptic.fromBig"
  "(crypto/elliptic.p256Curve).CombinedMult" -> "crypto/elliptic.p256Mul"
  "(crypto/elliptic.p256Curve).CombinedMult" -> "crypto/elliptic.p256Mul"
  "(crypto/elliptic.p256Curve).CombinedMult" -> "(*crypto/elliptic.p256Point).p256ScalarMult"
  "(crypto/elliptic.p256Curve).CombinedMult" -> "crypto/elliptic.p256PointAddAsm"
  "(crypto/elliptic.p256Curve).CombinedMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(crypto/elliptic.p256Curve).CombinedMult" -> "(*crypto/elliptic.p256Point).CopyConditional"
  "(crypto/elliptic.p256Curve).CombinedMult" -> "(*crypto/elliptic.p256Point).CopyConditional"
  "(crypto/elliptic.p256Curve).CombinedMult" -> "(*crypto/elliptic.p256Point).CopyConditional"
  "(crypto/elliptic.p256Curve).CombinedMult" -> "(*crypto/elliptic.p256Point).p256PointToAffine"
  "crypto/elliptic.zForAffine" -> "(*math/big.Int).Sign"
  "crypto/elliptic.zForAffine" -> "(*math/big.Int).SetInt64"
  "crypto/elliptic.zForAffine" -> "(*math/big.Int).Sign"
  "(*crypto/elliptic.CurveParams).Double" -> "crypto/elliptic.zForAffine"
  "(*crypto/elliptic.CurveParams).Double" -> "(*crypto/elliptic.CurveParams).doubleJacobian"
  "(*crypto/elliptic.CurveParams).Double" -> "(*crypto/elliptic.CurveParams).affineFromJacobian"
  "crypto/ecdsa.init" -> "crypto.init"
  "crypto/ecdsa.init" -> "crypto/aes.init"
  "crypto/ecdsa.init" -> "crypto/cipher.init"
  "crypto/ecdsa.init" -> "crypto/elliptic.init"
  "crypto/ecdsa.init" -> "crypto/sha512.init"
  "crypto/ecdsa.init" -> "encoding/asn1.init"
  "crypto/ecdsa.init" -> "errors.init"
  "crypto/ecdsa.init" -> "io.init"
  "crypto/ecdsa.init" -> "math/big.init"
  "crypto/ecdsa.init" -> "crypto/internal/randutil.init"
  "crypto/ecdsa.init" -> "(*math/big.Int).SetInt64"
  "crypto/ecdsa.init" -> "errors.New"
  "(*crypto/elliptic.CurveParams).IsOnCurve" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).IsOnCurve" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).IsOnCurve" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).IsOnCurve" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).IsOnCurve" -> "(*math/big.Int).Lsh"
  "(*crypto/elliptic.CurveParams).IsOnCurve" -> "(*math/big.Int).Add"
  "(*crypto/elliptic.CurveParams).IsOnCurve" -> "(*math/big.Int).Sub"
  "(*crypto/elliptic.CurveParams).IsOnCurve" -> "(*math/big.Int).Add"
  "(*crypto/elliptic.CurveParams).IsOnCurve" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).IsOnCurve" -> "(*math/big.Int).Cmp"
  "github.com/quapka/go-analysis/rsa_ecc_operations/ecdsa-signing.init" -> "crypto/ecdsa.init"
  "github.com/quapka/go-analysis/rsa_ecc_operations/ecdsa-signing.init" -> "crypto/elliptic.init"
  "(*crypto/elliptic.CurveParams).Add" -> "crypto/elliptic.zForAffine"
  "(*crypto/elliptic.CurveParams).Add" -> "crypto/elliptic.zForAffine"
  "(*crypto/elliptic.CurveParams).Add" -> "(*crypto/elliptic.CurveParams).addJacobian"
  "(*crypto/elliptic.CurveParams).Add" -> "(*crypto/elliptic.CurveParams).affineFromJacobian"
}
