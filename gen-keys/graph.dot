  digraph callgraph {
  "runtime.clearpools" -> "crypto/elliptic.initAll"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Sqr"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Mul"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Sqr"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Mul"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Sqr"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Mul"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Sqr"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Mul"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Sqr"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Mul"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Sqr"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Mul"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Sqr"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Mul"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Sqr"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Mul"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Sqr"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Mul"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Sqr"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Mul"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Sqr"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Mul"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Sqr"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Mul"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Sqr"
  "crypto/elliptic.p256Inverse" -> "crypto/elliptic.p256Mul"
  "crypto/elliptic.initTable" -> "crypto/elliptic.p256Inverse"
  "crypto/elliptic.initTable" -> "crypto/elliptic.p256Sqr"
  "crypto/elliptic.initTable" -> "crypto/elliptic.p256Mul"
  "crypto/elliptic.initTable" -> "crypto/elliptic.p256Mul"
  "crypto/elliptic.initTable" -> "crypto/elliptic.p256Mul"
  "crypto/elliptic.initTable" -> "crypto/elliptic.p256PointDoubleAsm"
  "crypto/elliptic.initTable" -> "crypto/elliptic.p256PointDoubleAsm"
  "crypto/elliptic.initTable" -> "crypto/elliptic.p256PointAddAsm"
  "runtime.clearpools" -> "crypto/elliptic.initTable"
  "runtime.mstart1" -> "crypto/elliptic.initTable"
  "runtime.mstart1" -> "crypto/elliptic.initAll"
  "crypto/elliptic.initP224" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initP224" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initP224" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initP224" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initP224" -> "(*math/big.Int).SetString"
  "crypto/elliptic.p224FromBig" -> "(*math/big.Int).Bytes"
  "crypto/elliptic.p224FromBig" -> "crypto/elliptic.get28BitsFromEnd"
  "crypto/elliptic.p224FromBig" -> "crypto/elliptic.get28BitsFromEnd"
  "crypto/elliptic.p224FromBig" -> "crypto/elliptic.get28BitsFromEnd"
  "crypto/elliptic.p224FromBig" -> "crypto/elliptic.get28BitsFromEnd"
  "crypto/elliptic.p224FromBig" -> "crypto/elliptic.get28BitsFromEnd"
  "crypto/elliptic.p224FromBig" -> "crypto/elliptic.get28BitsFromEnd"
  "crypto/elliptic.p224FromBig" -> "crypto/elliptic.get28BitsFromEnd"
  "crypto/elliptic.p224FromBig" -> "crypto/elliptic.get28BitsFromEnd"
  "crypto/elliptic.initP224" -> "crypto/elliptic.p224FromBig"
  "crypto/elliptic.initP224" -> "crypto/elliptic.p224FromBig"
  "crypto/elliptic.initP224" -> "crypto/elliptic.p224FromBig"
  "crypto/elliptic.initAll" -> "crypto/elliptic.initP224"
  "crypto/elliptic.initP256" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initP256" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initP256" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initP256" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initP256" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initAll" -> "crypto/elliptic.initP256"
  "crypto/elliptic.initP384" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initP384" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initP384" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initP384" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initP384" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initAll" -> "crypto/elliptic.initP384"
  "crypto/elliptic.initP521" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initP521" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initP521" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initP521" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initP521" -> "(*math/big.Int).SetString"
  "crypto/elliptic.initAll" -> "crypto/elliptic.initP521"
  "(*sync.Once).Do" -> "crypto/elliptic.initAll"
  "(*sync.Once).Do" -> "crypto/elliptic.initTable"
  "crypto/rsa.GenerateMultiPrimeKey" -> "crypto/internal/randutil.MaybeReadByte"
  "crypto/rsa.GenerateMultiPrimeKey" -> "errors.New"
  "crypto/rsa.GenerateMultiPrimeKey" -> "math.Log"
  "crypto/rsa.GenerateMultiPrimeKey" -> "errors.New"
  "crypto/rsa.GenerateMultiPrimeKey" -> "crypto/rand.Prime"
  "crypto/rsa.GenerateMultiPrimeKey" -> "(*math/big.Int).BitLen"
  "crypto/rsa.GenerateMultiPrimeKey" -> "(*math/big.Int).Set"
  "crypto/rsa.GenerateMultiPrimeKey" -> "(*math/big.Int).Set"
  "crypto/rsa.GenerateMultiPrimeKey" -> "(*math/big.Int).Cmp"
  "crypto/rsa.GenerateMultiPrimeKey" -> "(*math/big.Int).Mul"
  "crypto/rsa.GenerateMultiPrimeKey" -> "(*math/big.Int).Sub"
  "crypto/rsa.GenerateMultiPrimeKey" -> "(*math/big.Int).Mul"
  "crypto/rsa.GenerateMultiPrimeKey" -> "(*math/big.Int).BitLen"
  "crypto/rsa.GenerateMultiPrimeKey" -> "math/big.NewInt"
  "crypto/rsa.GenerateMultiPrimeKey" -> "(*math/big.Int).ModInverse"
  "(*crypto/rsa.PrivateKey).Precompute" -> "(*math/big.Int).Sub"
  "(*crypto/rsa.PrivateKey).Precompute" -> "(*math/big.Int).Mod"
  "(*crypto/rsa.PrivateKey).Precompute" -> "(*math/big.Int).Sub"
  "(*crypto/rsa.PrivateKey).Precompute" -> "(*math/big.Int).Mod"
  "(*crypto/rsa.PrivateKey).Precompute" -> "(*math/big.Int).ModInverse"
  "(*crypto/rsa.PrivateKey).Precompute" -> "(*math/big.Int).Mul"
  "(*crypto/rsa.PrivateKey).Precompute" -> "(*math/big.Int).Sub"
  "(*crypto/rsa.PrivateKey).Precompute" -> "(*math/big.Int).Mod"
  "(*crypto/rsa.PrivateKey).Precompute" -> "(*math/big.Int).Set"
  "(*crypto/rsa.PrivateKey).Precompute" -> "(*math/big.Int).ModInverse"
  "(*crypto/rsa.PrivateKey).Precompute" -> "(*math/big.Int).Mul"
  "crypto/rsa.GenerateMultiPrimeKey" -> "(*crypto/rsa.PrivateKey).Precompute"
  "(*crypto/elliptic.CurveParams).IsOnCurve" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).IsOnCurve" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).IsOnCurve" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).IsOnCurve" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).IsOnCurve" -> "(*math/big.Int).Lsh"
  "(*crypto/elliptic.CurveParams).IsOnCurve" -> "(*math/big.Int).Add"
  "(*crypto/elliptic.CurveParams).IsOnCurve" -> "(*math/big.Int).Sub"
  "(*crypto/elliptic.CurveParams).IsOnCurve" -> "(*math/big.Int).Add"
  "(*crypto/elliptic.CurveParams).IsOnCurve" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).IsOnCurve" -> "(*math/big.Int).Cmp"
  "crypto/ecdsa.init" -> "crypto.init"
  "crypto/ecdsa.init" -> "crypto/aes.init"
  "crypto/ecdsa.init" -> "crypto/cipher.init"
  "crypto/elliptic.init" -> "io.init"
  "crypto/elliptic.init" -> "math/big.init"
  "crypto/elliptic.init" -> "sync.init"
  "crypto/ecdsa.init" -> "crypto/elliptic.init"
  "crypto/ecdsa.init" -> "crypto/sha512.init"
  "crypto/ecdsa.init" -> "encoding/asn1.init"
  "crypto/ecdsa.init" -> "errors.init"
  "crypto/ecdsa.init" -> "io.init"
  "crypto/ecdsa.init" -> "math/big.init"
  "crypto/ecdsa.init" -> "crypto/internal/randutil.init"
  "crypto/ecdsa.init" -> "(*math/big.Int).SetInt64"
  "crypto/ecdsa.init" -> "errors.New"
  "crypto/elliptic.zForAffine" -> "(*math/big.Int).Sign"
  "crypto/elliptic.zForAffine" -> "(*math/big.Int).SetInt64"
  "crypto/elliptic.zForAffine" -> "(*math/big.Int).Sign"
  "(crypto/elliptic.p256Curve).Inverse" -> "(*math/big.Int).Sign"
  "(crypto/elliptic.p256Curve).Inverse" -> "(*math/big.Int).Neg"
  "(crypto/elliptic.p256Curve).Inverse" -> "(*math/big.Int).Cmp"
  "(crypto/elliptic.p256Curve).Inverse" -> "(*math/big.Int).Mod"
  "crypto/elliptic.fromBig" -> "(*math/big.Int).Bits"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.fromBig"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdMul"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdSqr"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdMul"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdMul"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdMul"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdSqr"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdMul"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdSqr"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdMul"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdSqr"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdMul"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdMul"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdSqr"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdMul"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdSqr"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdMul"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdSqr"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdMul"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdSqr"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdMul"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdSqr"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdMul"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdSqr"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdMul"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256OrdMul"
  "(crypto/elliptic.p256Curve).Inverse" -> "crypto/elliptic.p256LittleToBig"
  "(crypto/elliptic.p256Curve).Inverse" -> "(*math/big.Int).SetBytes"
  "(*crypto/elliptic.CurveParams).ScalarMult" -> "(*math/big.Int).SetInt64"
  "(*crypto/elliptic.CurveParams).affineFromJacobian" -> "(*math/big.Int).Sign"
  "(*crypto/elliptic.CurveParams).affineFromJacobian" -> "(*math/big.Int).ModInverse"
  "(*crypto/elliptic.CurveParams).affineFromJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).affineFromJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).affineFromJacobian" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).affineFromJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).affineFromJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).affineFromJacobian" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).ScalarMult" -> "(*crypto/elliptic.CurveParams).affineFromJacobian"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Sub"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Sign"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Add"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Add"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Set"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Lsh"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Add"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Lsh"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Sub"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Sign"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Add"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Add"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Sub"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Sign"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Add"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Sub"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Sign"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Add"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Lsh"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Sub"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Sign"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Add"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Lsh"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Sub"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Sign"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Add"
  "(*crypto/elliptic.CurveParams).doubleJacobian" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).ScalarMult" -> "(*crypto/elliptic.CurveParams).doubleJacobian"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Sign"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Set"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Set"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Set"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Sign"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Set"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Set"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Set"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Sub"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Sign"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Sign"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Add"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Lsh"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Sub"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Sign"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Add"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Sign"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*crypto/elliptic.CurveParams).doubleJacobian"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Lsh"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Set"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Sub"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Sub"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Sub"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Set"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Sub"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Lsh"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Sub"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Add"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Sub"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Sub"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mul"
  "(*crypto/elliptic.CurveParams).addJacobian" -> "(*math/big.Int).Mod"
  "(*crypto/elliptic.CurveParams).ScalarMult" -> "(*crypto/elliptic.CurveParams).addJacobian"
  "(*crypto/elliptic.CurveParams).Add" -> "crypto/elliptic.zForAffine"
  "(*crypto/elliptic.CurveParams).Add" -> "crypto/elliptic.zForAffine"
  "(*crypto/elliptic.CurveParams).Add" -> "(*crypto/elliptic.CurveParams).addJacobian"
  "(*crypto/elliptic.CurveParams).Add" -> "(*crypto/elliptic.CurveParams).affineFromJacobian"
  "github.com/quapka/go-analysis/gen-keys.main" -> "github.com/akamensky/argparse.NewParser"
  "github.com/quapka/go-analysis/gen-keys.main" -> "(*github.com/akamensky/argparse.Command).NewCommand"
  "github.com/quapka/go-analysis/gen-keys.main" -> "(*github.com/akamensky/argparse.Command).Int"
  "github.com/quapka/go-analysis/gen-keys.main" -> "(*github.com/akamensky/argparse.Command).NewCommand"
  "github.com/quapka/go-analysis/gen-keys.main" -> "(*github.com/akamensky/argparse.Command).Int"
  "github.com/quapka/go-analysis/gen-keys.main" -> "(*github.com/akamensky/argparse.Parser).Parse"
  "github.com/quapka/go-analysis/gen-keys.main" -> "(*github.com/akamensky/argparse.Command).Usage"
  "github.com/quapka/go-analysis/gen-keys.main" -> "fmt.Print"
  "github.com/quapka/go-analysis/gen-keys.main" -> "(*github.com/akamensky/argparse.Command).Happened"
  "github.com/quapka/go-analysis/gen-keys.main" -> "fmt.Sprintf"
  "github.com/quapka/go-analysis/gen-keys.main" -> "os.OpenFile"
  "github.com/quapka/go-analysis/gen-keys.main" -> "(*github.com/akamensky/argparse.Command).Happened"
  "github.com/quapka/go-analysis/gen-keys.main" -> "fmt.Sprintf"
  "github.com/quapka/go-analysis/gen-keys.main" -> "log.Fatal"
  "github.com/quapka/go-analysis/gen-keys.main" -> "log.Fatal"
  "github.com/quapka/go-analysis/gen-keys.main" -> "(*github.com/akamensky/argparse.Command).Happened"
  "github.com/quapka/go-analysis/gen-keys.writeRow" -> "(*os.File).Write"
  "github.com/quapka/go-analysis/gen-keys.writeRow" -> "log.Fatal"
  "github.com/quapka/go-analysis/gen-keys.main" -> "github.com/quapka/go-analysis/gen-keys.writeRow"
  "github.com/quapka/go-analysis/gen-keys.main" -> "(*os.File).Close"
  "github.com/quapka/go-analysis/gen-keys.main" -> "(*github.com/akamensky/argparse.Command).Happened"
  "github.com/quapka/go-analysis/gen-keys.getRSAData" -> "time.Now"
  "crypto/rsa.GenerateKey" -> "crypto/rsa.GenerateMultiPrimeKey"
  "github.com/quapka/go-analysis/gen-keys.getRSAData" -> "crypto/rsa.GenerateKey"
  "github.com/quapka/go-analysis/gen-keys.getRSAData" -> "time.Now"
  "github.com/quapka/go-analysis/gen-keys.getRSAData" -> "(time.Time).Sub"
  "github.com/quapka/go-analysis/gen-keys.getRSAData" -> "log.Fatal"
  "github.com/quapka/go-analysis/gen-keys.getRSAData" -> "(time.Duration).Nanoseconds"
  "github.com/quapka/go-analysis/gen-keys.getRSAData" -> "fmt.Sprintf"
  "github.com/quapka/go-analysis/gen-keys.main" -> "github.com/quapka/go-analysis/gen-keys.getRSAData"
  "github.com/quapka/go-analysis/gen-keys.main" -> "fmt.Sprintf"
  "github.com/quapka/go-analysis/gen-keys.main" -> "github.com/quapka/go-analysis/gen-keys.writeRow"
  "github.com/quapka/go-analysis/gen-keys.main" -> "github.com/quapka/go-analysis/gen-keys.writeRow"
  "github.com/quapka/go-analysis/gen-keys.main" -> "log.Fatal"
  "crypto/elliptic.P256" -> "(*sync.Once).Do"
  "github.com/quapka/go-analysis/gen-keys.getECCData" -> "crypto/elliptic.P256"
  "github.com/quapka/go-analysis/gen-keys.getECCData" -> "time.Now"
  "crypto/ecdsa.randFieldElement" -> "(crypto/elliptic.p256Curve).Params"
  "crypto/ecdsa.randFieldElement" -> "(*math/big.Int).Add"
  "crypto/ecdsa.randFieldElement" -> "(*math/big.Int).Mod"
  "crypto/ecdsa.randFieldElement" -> "(*crypto/elliptic.CurveParams).Params"
  "crypto/ecdsa.randFieldElement" -> "io.ReadFull"
  "crypto/ecdsa.randFieldElement" -> "(*math/big.Int).SetBytes"
  "crypto/ecdsa.randFieldElement" -> "(*math/big.Int).Sub"
  "crypto/ecdsa.GenerateKey" -> "crypto/ecdsa.randFieldElement"
  "crypto/ecdsa.GenerateKey" -> "(*math/big.Int).Bytes"
  "crypto/elliptic.p256GetScalar" -> "(*math/big.Int).SetBytes"
  "crypto/elliptic.p256GetScalar" -> "(*math/big.Int).Cmp"
  "crypto/elliptic.p256GetScalar" -> "(*math/big.Int).Mod"
  "crypto/elliptic.p256GetScalar" -> "crypto/elliptic.fromBig"
  "(crypto/elliptic.p256Curve).ScalarBaseMult" -> "crypto/elliptic.p256GetScalar"
  "(*crypto/elliptic.p256Point).p256BaseMult" -> "(*sync.Once).Do"
  "(*crypto/elliptic.p256Point).p256BaseMult" -> "crypto/elliptic.boothW6"
  "(*crypto/elliptic.p256Point).p256BaseMult" -> "crypto/elliptic.p256SelectBase"
  "(*crypto/elliptic.p256Point).p256BaseMult" -> "crypto/elliptic.p256NegCond"
  "(*crypto/elliptic.p256Point).p256BaseMult" -> "crypto/elliptic.boothW6"
  "(*crypto/elliptic.p256Point).p256BaseMult" -> "crypto/elliptic.p256SelectBase"
  "(*crypto/elliptic.p256Point).p256BaseMult" -> "crypto/elliptic.p256PointAddAffineAsm"
  "(crypto/elliptic.p256Curve).ScalarBaseMult" -> "(*crypto/elliptic.p256Point).p256BaseMult"
  "(*crypto/elliptic.p256Point).p256PointToAffine" -> "crypto/elliptic.p256Inverse"
  "(*crypto/elliptic.p256Point).p256PointToAffine" -> "crypto/elliptic.p256Sqr"
  "(*crypto/elliptic.p256Point).p256PointToAffine" -> "crypto/elliptic.p256Mul"
  "(*crypto/elliptic.p256Point).p256PointToAffine" -> "crypto/elliptic.p256Mul"
  "(*crypto/elliptic.p256Point).p256PointToAffine" -> "crypto/elliptic.p256Mul"
  "(*crypto/elliptic.p256Point).p256PointToAffine" -> "crypto/elliptic.p256FromMont"
  "(*crypto/elliptic.p256Point).p256PointToAffine" -> "crypto/elliptic.p256FromMont"
  "(*crypto/elliptic.p256Point).p256PointToAffine" -> "crypto/elliptic.p256LittleToBig"
  "(*crypto/elliptic.p256Point).p256PointToAffine" -> "crypto/elliptic.p256LittleToBig"
  "(*crypto/elliptic.p256Point).p256PointToAffine" -> "(*math/big.Int).SetBytes"
  "(*crypto/elliptic.p256Point).p256PointToAffine" -> "(*math/big.Int).SetBytes"
  "(crypto/elliptic.p256Curve).ScalarBaseMult" -> "(*crypto/elliptic.p256Point).p256PointToAffine"
  "crypto/ecdsa.GenerateKey" -> "(crypto/elliptic.p256Curve).ScalarBaseMult"
  "(*crypto/elliptic.CurveParams).ScalarBaseMult" -> "(*crypto/elliptic.CurveParams).ScalarMult"
  "crypto/ecdsa.GenerateKey" -> "(*crypto/elliptic.CurveParams).ScalarBaseMult"
  "github.com/quapka/go-analysis/gen-keys.getECCData" -> "crypto/ecdsa.GenerateKey"
  "github.com/quapka/go-analysis/gen-keys.getECCData" -> "time.Now"
  "github.com/quapka/go-analysis/gen-keys.getECCData" -> "(time.Time).Sub"
  "github.com/quapka/go-analysis/gen-keys.getECCData" -> "log.Fatal"
  "github.com/quapka/go-analysis/gen-keys.getECCData" -> "(time.Duration).Nanoseconds"
  "github.com/quapka/go-analysis/gen-keys.getECCData" -> "fmt.Sprintf"
  "github.com/quapka/go-analysis/gen-keys.main" -> "github.com/quapka/go-analysis/gen-keys.getECCData"
  "github.com/quapka/go-analysis/gen-keys.main" -> "fmt.Sprintf"
  "github.com/quapka/go-analysis/gen-keys.main" -> "github.com/quapka/go-analysis/gen-keys.writeRow"
  "github.com/quapka/go-analysis/gen-keys.main" -> "log.Fatal"
  "crypto/elliptic.maybeReduceModP" -> "(*math/big.Int).Cmp"
  "crypto/elliptic.maybeReduceModP" -> "(*math/big.Int).Mod"
  "(crypto/elliptic.p256Curve).ScalarMult" -> "crypto/elliptic.p256GetScalar"
  "(crypto/elliptic.p256Curve).ScalarMult" -> "crypto/elliptic.maybeReduceModP"
  "(crypto/elliptic.p256Curve).ScalarMult" -> "crypto/elliptic.fromBig"
  "(crypto/elliptic.p256Curve).ScalarMult" -> "crypto/elliptic.maybeReduceModP"
  "(crypto/elliptic.p256Curve).ScalarMult" -> "crypto/elliptic.fromBig"
  "(crypto/elliptic.p256Curve).ScalarMult" -> "crypto/elliptic.p256Mul"
  "(crypto/elliptic.p256Curve).ScalarMult" -> "crypto/elliptic.p256Mul"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "(*crypto/elliptic.p256Point).p256StorePoint"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "(*crypto/elliptic.p256Point).p256StorePoint"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "(*crypto/elliptic.p256Point).p256StorePoint"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "(*crypto/elliptic.p256Point).p256StorePoint"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "(*crypto/elliptic.p256Point).p256StorePoint"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointAddAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointAddAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointAddAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "(*crypto/elliptic.p256Point).p256StorePoint"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "(*crypto/elliptic.p256Point).p256StorePoint"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "(*crypto/elliptic.p256Point).p256StorePoint"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "(*crypto/elliptic.p256Point).p256StorePoint"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "(*crypto/elliptic.p256Point).p256StorePoint"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointAddAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointAddAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "(*crypto/elliptic.p256Point).p256StorePoint"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "(*crypto/elliptic.p256Point).p256StorePoint"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "(*crypto/elliptic.p256Point).p256StorePoint"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "(*crypto/elliptic.p256Point).p256StorePoint"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointAddAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointAddAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "(*crypto/elliptic.p256Point).p256StorePoint"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "(*crypto/elliptic.p256Point).p256StorePoint"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.boothW5"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256Select"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.boothW5"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256Select"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256NegCond"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointAddAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256MovCond"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256MovCond"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.boothW5"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256Select"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256NegCond"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256PointAddAsm"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256MovCond"
  "(*crypto/elliptic.p256Point).p256ScalarMult" -> "crypto/elliptic.p256MovCond"
  "(crypto/elliptic.p256Curve).ScalarMult" -> "(*crypto/elliptic.p256Point).p256ScalarMult"
  "(crypto/elliptic.p256Curve).ScalarMult" -> "(*crypto/elliptic.p256Point).p256PointToAffine"
  "(*crypto/elliptic.CurveParams).Double" -> "crypto/elliptic.zForAffine"
  "(*crypto/elliptic.CurveParams).Double" -> "(*crypto/elliptic.CurveParams).doubleJacobian"
  "(*crypto/elliptic.CurveParams).Double" -> "(*crypto/elliptic.CurveParams).affineFromJacobian"
  "(crypto/elliptic.p256Curve).CombinedMult" -> "crypto/elliptic.p256GetScalar"
  "crypto/elliptic.scalarIsZero" -> "crypto/elliptic.uint64IsZero"
  "(crypto/elliptic.p256Curve).CombinedMult" -> "crypto/elliptic.scalarIsZero"
  "(crypto/elliptic.p256Curve).CombinedMult" -> "(*crypto/elliptic.p256Point).p256BaseMult"
  "(crypto/elliptic.p256Curve).CombinedMult" -> "crypto/elliptic.p256GetScalar"
  "(crypto/elliptic.p256Curve).CombinedMult" -> "crypto/elliptic.scalarIsZero"
  "(crypto/elliptic.p256Curve).CombinedMult" -> "crypto/elliptic.maybeReduceModP"
  "(crypto/elliptic.p256Curve).CombinedMult" -> "crypto/elliptic.fromBig"
  "(crypto/elliptic.p256Curve).CombinedMult" -> "crypto/elliptic.maybeReduceModP"
  "(crypto/elliptic.p256Curve).CombinedMult" -> "crypto/elliptic.fromBig"
  "(crypto/elliptic.p256Curve).CombinedMult" -> "crypto/elliptic.p256Mul"
  "(crypto/elliptic.p256Curve).CombinedMult" -> "crypto/elliptic.p256Mul"
  "(crypto/elliptic.p256Curve).CombinedMult" -> "(*crypto/elliptic.p256Point).p256ScalarMult"
  "(crypto/elliptic.p256Curve).CombinedMult" -> "crypto/elliptic.p256PointAddAsm"
  "(crypto/elliptic.p256Curve).CombinedMult" -> "crypto/elliptic.p256PointDoubleAsm"
  "(crypto/elliptic.p256Curve).CombinedMult" -> "(*crypto/elliptic.p256Point).CopyConditional"
  "(crypto/elliptic.p256Curve).CombinedMult" -> "(*crypto/elliptic.p256Point).CopyConditional"
  "(crypto/elliptic.p256Curve).CombinedMult" -> "(*crypto/elliptic.p256Point).CopyConditional"
  "(crypto/elliptic.p256Curve).CombinedMult" -> "(*crypto/elliptic.p256Point).p256PointToAffine"
  "crypto/rsa.init" -> "crypto.init"
  "crypto/rsa.init" -> "crypto/subtle.init"
  "crypto/rsa.init" -> "errors.init"
  "crypto/rsa.init" -> "io.init"
  "crypto/rsa.init" -> "math/big.init"
  "crypto/rsa.init" -> "crypto/internal/randutil.init"
  "crypto/rsa.init" -> "bytes.init"
  "crypto/rsa.init" -> "hash.init"
  "crypto/rsa.init" -> "crypto/rand.init"
  "crypto/rsa.init" -> "math.init"
  "crypto/rsa.init" -> "math/big.NewInt"
  "crypto/rsa.init" -> "math/big.NewInt"
  "crypto/rsa.init" -> "errors.New"
  "crypto/rsa.init" -> "errors.New"
  "crypto/rsa.init" -> "errors.New"
  "crypto/rsa.init" -> "errors.New"
  "crypto/rsa.init" -> "errors.New"
  "crypto/rsa.init" -> "errors.New"
  "github.com/quapka/go-analysis/gen-keys.init" -> "crypto/ecdsa.init"
  "github.com/quapka/go-analysis/gen-keys.init" -> "crypto/elliptic.init"
  "github.com/quapka/go-analysis/gen-keys.init" -> "crypto/rand.init"
  "github.com/quapka/go-analysis/gen-keys.init" -> "crypto/rsa.init"
  "github.com/quapka/go-analysis/gen-keys.init" -> "fmt.init"
  "github.com/quapka/go-analysis/gen-keys.init" -> "github.com/akamensky/argparse.init"
  "github.com/quapka/go-analysis/gen-keys.init" -> "io.init"
  "github.com/quapka/go-analysis/gen-keys.init" -> "log.init"
  "github.com/quapka/go-analysis/gen-keys.init" -> "os.init"
  "/usr/localgithub.com/quapka/go-analysis/gen-keys.init" -> "time.init"
  }
